<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reading from Sources · ZipStreams</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ZipStreams</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Reading from Sources</a><ul class="internal"><li><a class="tocitem" href="#Reading-archives-with-zipsource"><span>Reading archives with <code>zipsource</code></span></a></li><li><a class="tocitem" href="#Iterating-through-files-from-an-archive-on-disk"><span>Iterating through files from an archive on disk</span></a></li><li><a class="tocitem" href="#Verifying-the-content-of-ZIP-archives"><span>Verifying the content of ZIP archives</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../sinks/">Writing to Sinks</a></li><li><a class="tocitem" href="../info/">Printing Information</a></li><li><a class="tocitem" href="../misc/">Other Operations</a></li><li><a class="tocitem" href="../pathological/">Pathological Files</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reading from Sources</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reading from Sources</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/reallyasi9/ZipStreams.jl/blob/main/docs/src/sources.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sources:-Read-only-Streams-of-Data"><a class="docs-heading-anchor" href="#Sources:-Read-only-Streams-of-Data">Sources: Read-only Streams of Data</a><a id="Sources:-Read-only-Streams-of-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Sources:-Read-only-Streams-of-Data" title="Permalink"></a></h1><h2 id="Reading-archives-with-zipsource"><a class="docs-heading-anchor" href="#Reading-archives-with-zipsource">Reading archives with <code>zipsource</code></a><a id="Reading-archives-with-zipsource-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-archives-with-zipsource" title="Permalink"></a></h2><p>You can wrap any Julia readable <code>IO</code> object with the <code>zipsource</code> function. The returned object can be iterated to read archived files in archive order. Information about each file can be accessed throug the <code>info</code> method called on the object returned from the iterator. The object returned from the iterator is readable like any standard Julia <code>IO</code> object, but it is not writable.</p><p>Here are some examples:</p><h2 id="Iterating-through-files-from-an-archive-on-disk"><a class="docs-heading-anchor" href="#Iterating-through-files-from-an-archive-on-disk">Iterating through files from an archive on disk</a><a id="Iterating-through-files-from-an-archive-on-disk-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-through-files-from-an-archive-on-disk" title="Permalink"></a></h2><p>This is perhaps the most common way to work with ZIP archives: reading them from disk and doing things with the contained files. Because <code>zipsource</code> reads from the beginning of the file to the end, you can only iterate through files in archive order and cannot randomly access files. Here is an example of how to work with this kind of file iteration:</p><pre><code class="language-julia hljs">using ZipStreams

# open an archive from an IO object
open(&quot;archive.zip&quot;) do io
    zs = zipsource(io)

    # iterate through files
    for f in zs
        
        # get information about each file from the info method
        println(info(f).name)

        # read from the file just like any other IO object
        println(readline(f))
        
        println(read(f, String))
    end
end</code></pre><p>You can use the <code>next_file</code> method to access the next file in the archive without iterating in a loop. The method returns <code>nothing</code> if it reaches the end of the archive.</p><pre><code class="language-julia hljs">using ZipStreams

open(&quot;archive.zip&quot;) do io
    zs = zipsource(io)
    f = next_file(zs) # the first file in the archive, or nothing if there are no files archived
    # ...
    f = next_file(zs) # the next file in the archive, or nothing if there was only one file
    # ...
end</code></pre><p>Because reading ZIP files from an archive on disk is a common use case, a convenience method taking a file name argument is provided:</p><pre><code class="language-julia hljs">using ZipStreams

zs = zipsource(&quot;archive.zip&quot;) # Note: the caller is responsible for closing this to free the file handle
# ... 
close(zs)</code></pre><p>In addition, a method that takes as its first argument a unary function is included so that users can manage the lifetime of any file handles opened by <code>zipsource</code> in an <code>open() do x ... end</code> block:</p><pre><code class="language-julia hljs">using ZipStreams

zipsource(&quot;archive.zip&quot;) do zs
    # ...
end # file handle is automatically closed at the end of the block</code></pre><p>The same method is defined for <code>IO</code> arguments, but it works slightly differently: the object passed is <em>not</em> closed when the block ends. It assumes that the caller is responsible for the <code>IO</code> object&#39;s lifetime. However, manually calling <code>close</code> on the source will always close the wrapped <code>IO</code> object. Here is an example:</p><pre><code class="language-julia hljs">using ZipStreams

io = open(&quot;archive.zip&quot;)
zipsource(io) do zs
    # ...
end
@assert isopen(io) == true

seekstart(io)
zipsource(io) do zs
    # ...
    close(zs) # called manually
end
@assert isopen(io) == false</code></pre><h2 id="Verifying-the-content-of-ZIP-archives"><a class="docs-heading-anchor" href="#Verifying-the-content-of-ZIP-archives">Verifying the content of ZIP archives</a><a id="Verifying-the-content-of-ZIP-archives-1"></a><a class="docs-heading-anchor-permalink" href="#Verifying-the-content-of-ZIP-archives" title="Permalink"></a></h2><p>A ZIP archive stores file sizes and checksums in two of three locations: one of  either immediately before the archived file data (in the &quot;Local File Header&quot;) or immediately after the archived file data (in the &quot;Data Descriptor&quot;), and always at the end of the file (in the &quot;Central Directory&quot;). Because the Central Directory is considered the ground truth, the Local File Header and Data Descriptor may report inaccurate values. To verify that the content of the file matches the values in the Local File Header, use the <code>validate</code> method on the archived file. To verify that all file content in the archive matches the values in the Central Directory, use the <code>validate</code> method on the archive itself. These methods will throw an error if they detect any inconsistencies.</p><p>For example, to validate the data in a single file stored in the archive:</p><pre><code class="language-julia hljs">using ZipStreams

zipsource(&quot;archive.zip&quot;) do zs
    f = next_file(zs)
    validate(f) # throws if there is an inconsistency
end</code></pre><p>To validate the data in all of the <em>remaining</em> files in the archive:</p><pre><code class="language-julia hljs">using ZipStreams

io = open(&quot;archive.zip&quot;)
zipsource(io) do zs
    validate(zs) # validate all files and the archive itself
end

seekstart(io)
zipsource(io) do zs
    f = next_file(zs) # read the first file
    validate(zs) # validate all files except the first!
end

close(io)</code></pre><p>The <code>validate</code> methods consume the data in the source and return vectors of raw bytes. When called on an archived file, it returns a single <code>Vector{UInt8}</code>. When called on the archive itself, it returns a <code>Vector{Vector{UInt8}}</code> containing the remaining unread file data in archive order, <em>excluding any files that have already been read by iterating or with `next</em>file`_.</p><pre><code class="language-julia hljs">using ZipStreams

zs = zipsource(&quot;archive.zip&quot;)
f1 = next_file(zs)
data1 = validate(f1) # contains all the file data as raw bytes
@assert typeof(data1) == Vector{UInt8}
close(zs)

zs = zipsource(&quot;archive.zip&quot;)
f2 = next_file(zs)
println(readline(f2)) # read a line off the file first
data2 = validate(f2) # contains the remaining file data excluding the first line!
@assert typeof(data2) == Vector{UInt8}
@assert sizeof(data2) &lt; sizeof(data1)
close(zs)

zs = zipsource(&quot;archive.zip&quot;)
all_data = validate(zs) # returns a Vector{Vector{UInt8}} of all remaining files
@assert all_data[1] == data1
close(zs)</code></pre><p>Note that these methods consume the data in the file or archive, as demonstrated in this example:</p><pre><code class="language-julia hljs">using ZipStreams

zs = zipsource(&quot;archive.zip&quot;)
validate(zs)
@assert eof(zs) == true</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.ZipArchiveSource" href="#ZipStreams.ZipArchiveSource"><code>ZipStreams.ZipArchiveSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZipArchiveSource</code></pre><p>A read-only lazy streamable representation of a Zip archive.</p><p>The authoritative record of files present in a Zip archive is stored in the Central Directory at the end of the archive. This allows for easy appending of new files to the archive by overwriting the Central Directory and adding a new Central Directory with the updated contents afterward. It also allows for easy deletion of files from the old archive by overwriting the Central Directory with the updated contents and relying on compliant Zip archive extraction programs ignoring the actual bytes in the file and only trusting the new Central Directory.</p><p>Unfortunately, this choice makes reading the contents of a Zip archive sub-optimal, especially over streaming IO interfaces like networks, where seeking to the end of the file requires reading all of the file&#39;s contents first.</p><p>However, this package chooses not to be a compliant Zip archive reader. By ignoring the Central Directory, one can begin extracting data from a Zip archive immediately upon reading the first Local File Header record it sees in the stream, greatly reducing latency to first read on large files, and also reducing the amount of data necessary to cache on disk or in memory.</p><p>A <code>ZipArchiveSource</code> is a wapper around an <code>IO</code> object that allows the user to extract files as they are read from the stream instead of waiting to read the file information from the Central Directory at the end of the stream.</p><p><code>ZipArchiveSource</code> objects can be iterated. Each iteration returns an IO object that will lazily extract (and decompress) file data from the archive.</p><p>Information about each file in the archive is stored in the <code>directory</code> property of the struct as the file is read from the archive.</p><p>Create <code>ZipArchiveSource</code> objects using the <a href="#ZipStreams.zipsource"><code>zipsource</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/eeb59fccc35df1be7500ad325c7c7551c6b4f7ad/src/input_stream.jl#L181-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.zipsource" href="#ZipStreams.zipsource"><code>ZipStreams.zipsource</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zipsource(io)
zipsource(f, io)</code></pre><p>Create a read-only lazy streamable representation of a Zip archive.</p><p>The first form returns a <code>ZipArchiveSource</code> wrapped around <code>io</code> that allows the user to extract files as they are read from the stream by iterating over the returned object. <code>io</code> can be an object that inherits from <code>Base.IO</code> (technically only requiring <code>read</code>, <code>eof</code>, <code>isopen</code>, <code>close</code>, and <code>bytesavailable</code> to be defined) or an <code>AbstractString</code> file name, which will open the file in read-only mode and wrap that <code>IOStream</code>.</p><p>The second form takes a unary function as the first argument. The constructed <code>ZipArchiveSource</code> object will be passed to the function and the results of the function will be returned to the user. This allows compatability with <code>do</code> blocks. If <code>io</code> is an <code>AbstractString</code> file name, the file will be automatically closed when the block exits. If <code>io</code> is a <code>Base.IO</code> object as described above, it will <em>not</em> be closed when the block exits, allowing the caller to have control over the lifetime of the argument.</p><div class="admonition is-warning"><header class="admonition-header">Reading before knowing where files end can be dangerous!</header><div class="admonition-body"><p>The Central Directory in the Zip archive is the <em>authoritative source</em> for file locations, compressed and uncompressed sizes, and CRC-32 checksums. A Local File Header can lie about this information, leading to improper file extraction.  We <strong>highly</strong> recommend that users validate the file contents against the Central Directory using the <code>validate</code> method before beginning to trust the extracted files from uncontrolled sources.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/eeb59fccc35df1be7500ad325c7c7551c6b4f7ad/src/input_stream.jl#L269-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.next_file" href="#ZipStreams.next_file"><code>ZipStreams.next_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_file(archive) =&gt; Union{IO, Nothing}</code></pre><p>Read the next file in the archive and return a readable <code>IO</code> object or <code>nothing</code>.</p><p>This is the same as calling <code>first(iterate(archive))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/eeb59fccc35df1be7500ad325c7c7551c6b4f7ad/src/input_stream.jl#L390-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.validate" href="#ZipStreams.validate"><code>ZipStreams.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(zf::ZipFileSource) -&gt; Nothing</code></pre><p>Validate that the contents read from an archived file match the information stored in the Local File Header.</p><p>If the contents of the file do not match the information in the Local File Header, the method will throw an error. The method checks that the compressed and uncompressed file sizes match what is in the header and that the CRC-32 of the uncompressed data matches what is reported in the header.</p><p>Validation will work even on files that have been partially read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/eeb59fccc35df1be7500ad325c7c7551c6b4f7ad/src/validate.jl#L2-L14">source</a></section><section><div><pre><code class="nohighlight hljs">validate(source::ZipArchiveSource) -&gt; Nothing</code></pre><p>Validate the files in the archive <code>source</code> against the Central Directory at the end of the archive.</p><p>This method consumes <em>all</em> the remaining data in the source stream of <code>source</code> and throws an exception if the file information from the file headers read does not match the information in the Central Directory. Files that have already been consumed prior to calling this method will still be validated.</p><div class="admonition is-warning"><header class="admonition-header">Files using descriptors</header><div class="admonition-body"><p>If a file stored within <code>source</code> uses a File Descriptor rather than storing the size of the file in the Local File Header, the file must be read to the end in order to properly record the lengths for checking against the Central Directory. Failure to read such a file to the end will result in an error being thrown when <code>validate</code> is called on the archive.</p></div></div><p>See also <a href="#ZipStreams.validate"><code>validate(::ZipFileSource)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/eeb59fccc35df1be7500ad325c7c7551c6b4f7ad/src/validate.jl#L59-L77">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../sinks/">Writing to Sinks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 19 August 2024 01:04">Monday 19 August 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
