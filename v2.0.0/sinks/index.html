<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Writing to Sinks · ZipStreams</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ZipStreams</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../sources/">Reading from Sources</a></li><li class="is-active"><a class="tocitem" href>Writing to Sinks</a><ul class="internal"><li><a class="tocitem" href="#Creating-archives-and-writing-files-with-zipsink"><span>Creating archives and writing files with <code>zipsink</code></span></a></li><li><a class="tocitem" href="#Writing-files-to-an-archive-all-at-once-with-write_file"><span>Writing files to an archive all at once with <code>write_file</code></span></a></li><li><a class="tocitem" href="#Creating-directories-in-an-archive"><span>Creating directories in an archive</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../info/">Printing Information</a></li><li><a class="tocitem" href="../misc/">Other Operations</a></li><li><a class="tocitem" href="../pathological/">Pathological Files</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Writing to Sinks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Writing to Sinks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/reallyasi9/ZipStreams.jl/blob/main/docs/src/sinks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sinks:-Write-only-Streams-of-Data"><a class="docs-heading-anchor" href="#Sinks:-Write-only-Streams-of-Data">Sinks: Write-only Streams of Data</a><a id="Sinks:-Write-only-Streams-of-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Sinks:-Write-only-Streams-of-Data" title="Permalink"></a></h1><h2 id="Creating-archives-and-writing-files-with-zipsink"><a class="docs-heading-anchor" href="#Creating-archives-and-writing-files-with-zipsink">Creating archives and writing files with <code>zipsink</code></a><a id="Creating-archives-and-writing-files-with-zipsink-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-archives-and-writing-files-with-zipsink" title="Permalink"></a></h2><p>You can wrap any <code>IO</code> object that supports writing bytes (any type that implements <code>unsafe_write(::T, ::Ptr{UInt8}, ::UInt)</code>) in a special ZIP archive writer with the <code>zipsink</code> function. The function will return an object that allows creating and writing files within the archive. You can then call <code>open(sink, filename)</code> using the returned object to create a new file in the archive and begin writing to it with standard <code>IO</code> functions.</p><p>This example creates a new ZIP archive file on disk, creates a new file within the archive, writes data to the file, then closes the file and archive:</p><pre><code class="language-julia hljs">using ZipStreams

io = open(&quot;new-archive.zip&quot;, &quot;w&quot;)
sink = zipsink(io)
f = open(sink, &quot;hello.txt&quot;)
write(f, &quot;Hello, Julia!&quot;)
close(f)
close(sink)</code></pre><p>Convenience methods are included that create a new file on disk by passing a file name to <code>zipsink</code> instead of an <code>IO</code> object and that run a unary function so that <code>zipsink</code> can be used with a <code>do ... end</code> block. In addition, the <code>open(sink, filename)</code> method can also be used with a <code>do ... end</code> block, as this example shows:</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink  # create a new archive on disk and truncate it
    open(sink, &quot;hello.txt&quot;) do f  # create a new file in the archive
        write(f, &quot;Hello, Julia!&quot;)
    end  # automatically write a Data Descriptor to the archive and close the file
end  # automatically write the Central Directory and close the archive</code></pre><p>Note that the <code>IO</code> method does not automatically close the <code>IO</code> object after the <code>do</code> block ends. The caller of that signature is responsible for the lifetime of the <code>IO</code> object. The <code>IO</code> object can be closed before the end of the <code>do</code> block by calling <code>close</code> on the sink. Additional writes to a closed sink will cause an <code>ArgumentError</code> to be thrown, but closing a closed sink is a noop, as these examples show:</p><pre><code class="language-julia hljs">using ZipStreams

io = IOBuffer()
zipsink(io) do sink
    open(sink, &quot;hello.txt&quot;) do f
        write(f, &quot;Hello, Julia!&quot;)
    end
end
@assert isopen(io) == true

zipsink(io) do sink
    open(sink, &quot;goodbye.txt&quot;) do f
        write(f, &quot;Good bye, Julia!&quot;)
    end
    close(sink)
end
@assert isopen(io) == false</code></pre><p>Because the data are streamed to the archive, you can only have one file open for writing at a time in a given archive. If you try to open a new file before closing the previous file, a warning will be printed to the console and the previous file will automatically be closed. In addition, any file still open for writing when the archive is closed will automatically be closed before the archive is finalized, as this example demonstrates:</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink
    f1 = open(sink, &quot;hello.txt&quot;)
    write(f1, &quot;Hello, Julia!&quot;)
    f2 = open(sink, &quot;goodbye.txt&quot;)  # issues a warning and closes f1 before opening f2
    write(f2, &quot;Good bye, Julia!&quot;)
end  # automatically closes f2 before closing the archive</code></pre><h2 id="Writing-files-to-an-archive-all-at-once-with-write_file"><a class="docs-heading-anchor" href="#Writing-files-to-an-archive-all-at-once-with-write_file">Writing files to an archive all at once with <code>write_file</code></a><a id="Writing-files-to-an-archive-all-at-once-with-write_file-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-files-to-an-archive-all-at-once-with-write_file" title="Permalink"></a></h2><p>When you open a file for writing in a ZIP archive using <code>open(sink, filename)</code>, writing to the file is done in a streaming fashion with a Data Descriptor written at the end of the file data when it is closed. If you want to write an entire file to the archive at once, you can use the <code>write_file(sink, filename, data)</code> method. This method will write file size and checksum information to the archive in the Local File Header rather than using a Data Descriptor. The advantage to this method is that files written this way are more efficiently read back by a <code>zipsource</code>: when streamed for reading, the Local File Header will report the correct file size. The disadvantages to using this method for writing data are that you need to have all of the data you want to write available at one time and that both the raw data and the compressed data need to fit in memory. Here are some examples using this method for writing files:</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink
    open(sink, &quot;hello.txt&quot;) do f1
        write(f1, &quot;Hello, Julia!&quot;)  # writes using a Data Descriptor
    end
end


zipsource(&quot;new-archive.zip&quot;) do source
    f = next_file(source)  # works, but is slow to read because the stream has to be checked for a valid Data Descriptor with each read
    @assert read(f, String) == &quot;Hello, Julia!&quot;
end

zipsink(&quot;new-archive.zip&quot;) do sink
    text = &quot;Hello, Julia!&quot;
    write_file(sink, &quot;hello.txt&quot;, text)  # writes without a Data Descriptor
end

zipsource(&quot;new-archive.zip&quot;) do source
    f = next_file(source)  # is more efficient to read because the file size is known a priori
    @assert read(f, String) == &quot;Hello, Julia!&quot;
end</code></pre><h2 id="Creating-directories-in-an-archive"><a class="docs-heading-anchor" href="#Creating-directories-in-an-archive">Creating directories in an archive</a><a id="Creating-directories-in-an-archive-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-directories-in-an-archive" title="Permalink"></a></h2><p>Directories within a ZIP archive are nothing more than files with zero length and a name that ends in a forward slash (<code>/</code>). If you try to make a file using <code>open</code> or <code>write_file</code> that has a name ending in <code>/</code>, the method will throw an error. You can, however, make a directory by calling the <code>mkdir</code> and <code>mkpath</code> functions. They work similar to how <code>Base.mkdir</code> and <code>Base.mkpath</code> work: the former will throw an error if all of the parent directories do not exist, while the latter will create the parent directories as needed. Here are examples of these two functions:</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink
    try
        f = open(sink, &quot;file/&quot;)  # fails because files cannot end in &#39;/&#39;
    catch e
        @error &quot;exception caught&quot; exception=e
    end

    mkdir(sink, &quot;dir1/&quot;)  # creates a directory called &quot;dir1/&quot; in the root of the archive
    mkdir(sink, &quot;dir1/dir2/&quot;)  # creates &quot;dir2/&quot; as a subdirectory of &quot;dir1/&quot;

    try
        mkdir(sink, &quot;dir3/dir4/&quot;)  # fails because mkdir won&#39;t create parent directories
    catch e
        @error &quot;exception caught&quot; exception=e
    end
    
    mkpath(sink, &quot;dir3/dir4/&quot;)  # creates both &quot;dir3/&quot; and &quot;dir3/dir4/&quot;

    mkdir(sink, &quot;dir5&quot;)  # The ending slash will be appended to directory names automatically
end</code></pre><p>NOTE: Even on Windows computers, directory names in ZIP files always use forward slash (<code>/</code>) as a directory separator. Backslash characters (<code>\</code>) are treated as literal backslashes in the directory or filename, so <code>mkdir(sink, &quot;dir\\file&quot;)</code> will create a single file named <code>dir\file</code> and <em>not</em> a directory.</p><p>The <code>mkdir</code> and <code>mkpath</code> methods return the number of bytes written to the archive,  including the Local File Header required to define the directory, but <em>excluding</em> the Central Directory Header data (that will be written when the sink is closed).</p><p>The sink keeps track of which directories have been defined and skips creating directories that already exist, as this example demonstrates:</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink
    a = mkdir(sink, &quot;dir1/&quot;)  # returns the number of bytes written to the archive
    @assert a &gt; 0
    b = mkdir(sink, &quot;dir1/&quot;)
    @assert b == 0  # dir1 already exists, so nothing is written
    c = mkpath(sink, &quot;dir1/dir2&quot;)  # dir1 already exists, so do not recreate it
    d = mkpath(sink, &quot;dir3/dir4&quot;)  # dir3 has to be created along with dir4
    @assert d &gt; c  # the second call creates two directories, so more bytes are written
end</code></pre><p>Opening a new file in the sink that contains a non-trivial path will throw an error if the parent path does not exist. The keyword argument <code>make_path=true</code> will cause the method to create the parent path as if <code>mkpath</code> were called first:</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink
    try
        f = open(sink, &quot;dir1/file&quot;)  # fails because directory &quot;dir1/&quot; does not exist
    catch e
        @error &quot;exception caught&quot; exception=e
    end
    f = open(sink, &quot;dir1/file&quot;; make_path=true)  # creates &quot;dir1/&quot; first
    # ...
    close(f)
end</code></pre><p>Relative directory names <code>.</code> or <code>..</code> are interpreted as directories literally named <code>.</code> or <code>..</code> and <em>not</em> as relative paths. The root directory of the archive is unnamed, so attempts to create a directory named <code>/</code> will be ignored. Attempting to create an unnamed subdirectory will result in the unnamed subdirectory being ignored (e.g., <code>mkpath(sink, &quot;dir1//dir2&quot;)</code>  will do the same thing as <code>mkpath(sink, &quot;dir1/dir2&quot;)</code>). By rule, attempting to make a directory that appears to begin with a Windows drive specifier, even on a non-Windows OS, will throw an error (per 4.4.17 of the APPNOTE document).</p><pre><code class="language-julia hljs">using ZipStreams

zipsink(&quot;new-archive.zip&quot;) do sink
    @assert mkpath(sink, &quot;/&quot;) == 0  # &#39;/&#39; at the beginning is ignored
    mkpath(sink, &quot;/dir1&quot;)
    @assert mkpath(sink, &quot;dir1&quot;) == 0  # already created with &quot;/dir1&quot;
    
    mkpath(sink, &quot;dir1/////dir2&quot;)
    @assert mkpath(sink, &quot;dir1/dir2&quot;) == 0  # already created with &quot;dir1/////dir2&quot;

    try
        mkpath(sink, &quot;c:\\dir1&quot;)  # fails because directory appears to start with a drive specifier
    catch e
        @error &quot;exception caught&quot; exception=e
    end
    try
        mkpath(sink, &quot;q:dir1&quot;)  # fails for the same reason: the slash at the end doesn&#39;t matter
    catch e
        @error &quot;exception caught&quot; exception=e
    end
    try
        mkpath(sink, &quot;\\\\networkshare\\dir1&quot;)  # fails because Windows network drives count as drive specifiers
    catch e
        @error &quot;exception caught&quot; exception=e
    end
end</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.ZipArchiveSink" href="#ZipStreams.ZipArchiveSink"><code>ZipStreams.ZipArchiveSink</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZipArchiveSink</code></pre><p>A struct for appending to Zip archives.</p><p>Zip archives are optimized for appending to the end of the archive. This struct is used in tandem with library functions to keep track of what is appended to a Zip archive so that a proper Central Directory can be written at the end.</p><p>Users should not call the <code>ZipArchiveSink</code> constructor: instead, use the <a href="#ZipStreams.zipsink"><code>zipsink</code></a> method to create a new streaming archive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/89fd30cadd0b620b44c40cf5c78da0104c750e1f/src/output_stream.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.zipsink" href="#ZipStreams.zipsink"><code>ZipStreams.zipsink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zipsink(fname; [keyword arguments]) -&gt; ZipArchiveSink
zipsink(io; [keyword arguments]) -&gt; ZipArchiveSink
zipsink(f, args...)</code></pre><p>Open an <code>IO</code> stream of a Zip archive for writing data.</p><p><strong>Positional arguments</strong></p><ul><li><code>fname::AbstractString</code>: The name of a Zip archive file to open for writing. Will be created if the file does not exist. If the file does exist, it will be truncated before writing.</li><li><code>io::IO</code>: An <code>IO</code> object that can be written to. The object will be closed when you call <code>close</code> on the returned object.</li><li><code>f&lt;:Function</code>: A unary function to which the opened stream will be passed. This method signature allows for <code>do</code> block usage. When called with the signature, the return value of <code>f</code> will be returned to the user.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>utf8::Bool=true</code>: Encode file names and comments with UTF-8 encoding. If <code>false</code>, follows the Zip standard of treating text as encoded in IBM437 encoding.</li><li><code>comment::AbstractString=&quot;&quot;</code>: A comment to store with the Zip archive. This information is stored in plain text at the end of the archive and does not affect the Zip archive in any other way. The comment is always stored using IBM437 encoding.</li></ul><div class="admonition is-info"><header class="admonition-header">Using IO arguments</header><div class="admonition-body"><p>Passing an <code>IO</code> object as the first argument will use the object as-is, overwriting from the current position of the stream and writing the Central Directory after closing the stream without truncating the remainder. This use of <code>zipsink</code> is recommended for advanced users only who need to write Zip archives to write-only streams (e.g., network pipes).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/89fd30cadd0b620b44c40cf5c78da0104c750e1f/src/output_stream.jl#L219-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Filesystem.mkdir-Tuple{ZipStreams.ZipArchiveSink, AbstractString}" href="#Base.Filesystem.mkdir-Tuple{ZipStreams.ZipArchiveSink, AbstractString}"><code>Base.Filesystem.mkdir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mkdir(archive, path; comment=&quot;&quot;)</code></pre><p>Make a single directory within a ZIP archive.</p><p>Path elements in ZIP archives are separated by the forward slash character (<code>/</code>). Backslashes (<code>\</code>) and dots (<code>.</code> and <code>..</code>) are treated as literal characters in the directory or file names. The final forward slash character will automatically be added to the directory name when this method is used.</p><p>If any parent directory in the path does not exist, an error will be thrown. Use <a href="#Base.Filesystem.mkpath-Tuple{ZipStreams.ZipArchiveSink, AbstractString}"><code>mkpath</code></a> to create the entire path at once, including parent paths. Empty directory names (<code>//</code>) will be ignored, as will directories that have already been created in the archive.</p><p>The <code>comment</code> string will be added to the archive&#39;s metadata for the directory. It does not affect the stored data in any way.</p><p>Returns the number of bytes written to the archive when creating the directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/89fd30cadd0b620b44c40cf5c78da0104c750e1f/src/output_stream.jl#L313-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Filesystem.mkpath-Tuple{ZipStreams.ZipArchiveSink, AbstractString}" href="#Base.Filesystem.mkpath-Tuple{ZipStreams.ZipArchiveSink, AbstractString}"><code>Base.Filesystem.mkpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mkpath(archive, path; comment=&quot;&quot;)</code></pre><p>Make a directory and all its parent directories in a ZIP archive.</p><p>Path elements in ZIP archives are separated by the forward slash character (<code>/</code>). Backslashes (<code>\</code>) and dots (<code>.</code> and <code>..</code>) are treated as literal characters in the directory or file names. The final forward slash character will automatically be added to the directory name when this method is used.</p><p>If any parent directory in the path does not exist, it will be created automatically. Empty directory names (<code>//</code>) will be ignored, as will directories that have already been created in the archive.</p><p>The <code>comment</code> string will be added to the archive&#39;s metadata only for the last directory in the path. All other directories created by this method will have no comment. This does not affect the stored data in any way.</p><p>Returns the number of bytes written to the archive when creating the entire path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/89fd30cadd0b620b44c40cf5c78da0104c750e1f/src/output_stream.jl#L371-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open-Tuple{ZipStreams.ZipArchiveSink, AbstractString}" href="#Base.open-Tuple{ZipStreams.ZipArchiveSink, AbstractString}"><code>Base.open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open(sink, fname; [keyword arguments]) -&gt; IO</code></pre><p>Create a file within a Zip archive and return a handle for writing.</p><p><strong>Keyword arguments</strong></p><ul><li><code>compression::Union{UInt16,Symbol} = :deflate</code>: Can be one of <code>:deflate</code>, <code>:store</code>, or the associated codes defined by the Zip archive standard (<code>0x0008</code> or <code>0x0000</code>, respectively). Determines how the data is compressed when writing to the archive.</li><li><code>utf8::Bool = true</code>: If <code>true</code>, the file name and comment will be written to the archive metadata encoded in UTF-8 strings, and a flag will be set in the metadata to instruct decompression programs to read these strings as such. If <code>false</code>, the default IBM437 encoding will be used. This does not affect the file data itself.</li><li><code>comment::AbstractString = &quot;&quot;</code>: Comment metadata to add to the archive about the file. This does not affect the file data itself.</li><li><code>make_path::Bool = false</code>: If <code>true</code>, any directories in <code>fname</code> will be created first. If <code>false</code> and any directory in the path does not exist, an exception will be thrown.</li></ul><div class="admonition is-warning"><header class="admonition-header">Duplicate file names</header><div class="admonition-body"><p>The Zip archive specification does not clearly define what to do if multiple files in the Zip archive share the same name. This method will allow the user to create files with the same name in a single Zip archive, but other software may not behave as expected when reading the archive.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/89fd30cadd0b620b44c40cf5c78da0104c750e1f/src/output_stream.jl#L414-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ZipStreams.write_file" href="#ZipStreams.write_file"><code>ZipStreams.write_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_file(sink, fname, data; [keyword arguments])</code></pre><p>Archive <code>data</code> to a new file named <code>fname</code> in an archive sink all at once.</p><p>This is a convenience method that will create a new file in the archive with name <code>fname</code> and write all of <code>data</code> to that file. The <code>data</code> argument can be anything for which the method <code>write(io, data)</code> is defined.</p><p>Returns the number of bytes written to the archive.</p><p>Keyword arguments are the same as those accepted by <a href="#Base.open-Tuple{ZipStreams.ZipArchiveSink, AbstractString}"><code>open(::ZipArchiveSink, ::AbstractString)</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Memory requirements</header><div class="admonition-body"><p>This method reads <code>data</code> into a buffer before writing it to the archive. Both <code>data</code> and the buffered (potentially compressed) copy must be able to fit into memory simultaneously.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/ZipStreams.jl/blob/89fd30cadd0b620b44c40cf5c78da0104c750e1f/src/output_stream.jl#L521-L539">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sources/">« Reading from Sources</a><a class="docs-footer-nextpage" href="../info/">Printing Information »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 February 2023 03:48">Friday 3 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
